Downloaded from www.genome.org on May 7, 2008 - Published by Cold Spring Harbor Laboratory Press

The Bioperl Toolkit: Perl Modules for the Life Sciences
Jason E. Stajich, David Block, Kris Boulez, Steven E. Brenner, Stephen A. Chervitz, Chris Dagdigian, Georg Fuellen, James G.R. Gilbert, Ian Korf, Hilmar Lapp, Heikki Lehväslaiho, Chad Matsalla, Chris J. Mungall, Brian I. Osborne, Matthew R. Pocock, Peter Schattner, Martin Senger, Lincoln D. Stein, Elia Stupka, Mark D. Wilkinson and Ewan Birney Genome Res. 2002 12: 1611-1618 Access the most recent version at doi:10.1101/gr.361602

Supplementary data References

"Supplemental Research Data" http://www.genome.org/cgi/content/full/12/10/1611/DC1 This article cites 14 articles, 9 of which can be accessed free at: http://www.genome.org/cgi/content/full/12/10/1611#References Article cited in: http://www.genome.org/cgi/content/full/12/10/1611#otherarticles

Email alerting service

Receive free email alerts when new articles cite this article - sign up in the box at the top right corner of the article or click here

Notes

To subscribe to Genome Research go to: http://www.genome.org/subscriptions/

© 2002 Cold Spring Harbor Laboratory Press

Downloaded from www.genome.org on May 7, 2008 - Published by Cold Spring Harbor Laboratory Press

Resource

The Bioperl Toolkit: Perl Modules for the Life Sciences
Jason E. Stajich,1,18,19 David Block,2,18 Kris Boulez,3 Steven E. Brenner,4 Stephen A. Chervitz,5 Chris Dagdigian,6 Georg Fuellen,7 James G.R. Gilbert,8 Ian Korf,9 Hilmar Lapp,10 Heikki Lehvaslaiho,11 Chad Matsalla,12 Chris J. Mungall,13 ¨ 14 Brian I. Osborne, Matthew R. Pocock,8 Peter Schattner,15 Martin Senger,11 Lincoln D. Stein,16 Elia Stupka,17 Mark D. Wilkinson,2 and Ewan Birney11
University Program in Genetics, Duke University, Durham, North Carolina 27710, USA; 2National Research Council of Canada, Plant Biotechnology Institute, Saskatoon, SK S7N OW9 Canada; 3AlgoNomics, B 9052 Gent, Belgium; 4Department of Plant and Molecular Biology, University of California, Berkeley, California 94720, USA; 5Affymetrix, Inc., Emeryville, California 94608, USA; 6Open Bioinformatics Foundation, Somerville, Massachusetts 02144, USA; 7Integrated Functional Genomics, IZKF, University Hospital Muenster, 48149 Muenster, Germany; 8The Welcome Trust Sanger Institute, Welcome Trust Genome Campus, Hinxton, Cambridge, CB10 1SA UK; 9Department of Computer Science, Washington University, St. Louis, Missouri 63130, USA; 10Genomics Institute of the Novartis Research Foundation (GNF), San Diego, California 92121, USA; 11European Bioinformatics Institute, Welcome Trust Genome Campus, Hinxton, Cambridge CB10 1SD UK; 12Agriculture and Agri-Food Canada, Saskatoon Research Centre, Saskatoon SK, S7N 0X2 Canada; 13Berkeley Drosophila Genome Project, University of California, Berkeley, California 94720, USA; 14Cogina, New York City, New York 10022, USA; 15Center for Biomolecular Science and Engineering, University of California, Santa Cruz, California 95064, USA; 16Cold Spring Harbor Laboratory, Cold Spring Harbor, New York 11724, USA; 17Institute of Molecular and Cell Biology, 117609 Singapore The Bioperl project is an international open-source collaboration of biologists, bioinformaticians, and computer scientists that has evolved over the past 7 yr into the most comprehensive library of Perl modules available for managing and manipulating life-science information. Bioperl provides an easy-to-use, stable, and consistent programming interface for bioinformatics application programmers. The Bioperl modules have been successfully and repeatedly used to reduce otherwise complex tasks to only a few lines of code. The Bioperl object model has been proven to be flexible enough to support enterprise-level applications such as EnsEMBL, while maintaining an easy learning curve for novice Perl programmers. Bioperl is capable of executing analyses and processing results from programs such as BLAST, ClustalW, or the EMBOSS suite. Interoperation with modules written in Python and Java is supported through the evolving BioCORBA bridge. Bioperl provides access to data stores such as GenBank and SwissProt via a flexible series of sequence input/output modules, and to the emerging common sequence data storage format of the Open Bioinformatics Database Access project. This study describes the overall architecture of the toolkit, the problem domains that it addresses, and gives specific examples of how the toolkit can be used to solve common life-sciences problems. We conclude with a discussion of how the open-source nature of the project has contributed to the development effort. [Supplemental material is available online at www.genome.org. Bioperl is available as open-source software free of charge and is licensed under the Perl Artistic License (http://www.perl.com/pub/a/language/misc/Artistic. html). It is available for download at http://www.bioperl.org. Support inquiries should be addressed to bioperl-l@bioperl.org.]
1

Computational analysis is an integral part of modern biological research. Numerous computer software tools exist to perform data analyses, but it is not simple to automatically combine data and results from multiple sources without the use of computer software designed to read and write data specific to
18 Present address: Genomics Institute of the Novartis Research Foundation (GNF), San Diego, California 92121, USA. 19 Corresponding author. E-MAIL jason.stajich@duke.edu; FAX (919) 681-1035. Article and publication are at http://www.genome.org/cgi/doi/10.1101/ gr.361602.

the biological domain. The day-to-day work in a typical bioinformatics laboratory consists largely of writing program logic to achieve this data integration. Perl is one of the most widely used programming languages for these tasks and is commonly thought of as the language most easily grasped by newcomers to the field. Perl has been extremely successful for connecting software applications together into sequence analysis pipelines, converting file formats, and extracting information from the output of analysis programs and other text files. Much of the Perl software in bioinformatics is specific to

12:1611­1618 ©2002 by Cold Spring Harbor Laboratory Press ISSN 1088-9051/02 $5.00; www.genome.org

Genome Research
www.genome.org

1611

Downloaded from www.genome.org on May 7, 2008 - Published by Cold Spring Harbor Laboratory Press

Stajich et al.

different, the information they represent is the same. For example, a pair-wise alignment is always between two sequences and has common properties such as length, score, fraction of identities, start and end of the aligned sequences, and so forth. Second, the number of data structures needed to represent information flow is limited, and common to most applications such as sequences, annotation, features, and alignments. This permits a small set of modules to be reused for a variety of purposes. Third, a set of operations is commonly performed on these data structures. These include reading and writing information to a file, querying a sequence for its features, and translating a coding sequence into protein. This scenario naturally lends itself to the principle of object-oriented programming, which Perl emulates with modules. Object-oriented programming is the practice of grouping related tasks together into logical and broadly applicable components. For example, a DNA sequence component could contain methods to retrieve the sequence's accession number, reverse complement the DNA, or translate it into a protein sequence. Object-oriented programming methodology allows accurate modeling of the problem domain, leading to more robust, valid, and reusable code. Instead of attacking a problem by brute force, the problem is analyzed and models are constructed to represent the entities in the problem and solution domains. The entities are represented in code through the use of Perl modules and, where appropriate, form elements in an inheritance hierarchy. The use of inheritance and polymorphism in Bioperl implements the well-established principles of information hiding, modularity, and module cohesion (Tremblay and Cheston 2001). We designed Bioperl using object-oriented methodology Software Development Methodology so as to create clean, generic, and reusable modules to repreThe Bioperl project began in 1995 (Chervitz et al. 1998) at a sent data structures and operations common to the life scitime when there were few programming toolkits for manipuences. By separating the components into logical groups such lating biological data or results from sequence analysis proas sequences, alignments, and databases, we have been able to grams. Although Perl had already gained widespread popularadd features to a specific module without necessarily affecting ity in the bioinformatics community for its efficient support the rest of the toolkit library. This separation is a key aspect of of text processing and pattern matching tasks, there were, in object-oriented programming and permits us to produce gefact, no biological toolkits available in this language. neric components with a stable interface for the programmer The project grew out of the following observations. First, (the so-called API). even though file formats of different analysis programs are At present, the components and operations in Bioperl center around biological sequence analysis and annotation. In the last year, the project has expanded Table 1. Major Bioperl Module Groups to address new areas including phylogenetics, maps, protein strucModules Description ture, and bibliographic references. The project has >300 modules Bio Seq Sequences and their properties and comprises >160,000 lines of Bio SeqIO Sequence data input/output Bio Index Flat-file sequence database indexing and retrieval code and embedded documentaBio DB Remote database access for sequences and references via HTTP tion. The Perl modules, illustrated Bio DB GFF SQL GFF database for DAS and GBrowse backends in Table 1, are organized by logical Bio SeqFeature Annotations or features that have a sequence location names so that, for example, the Bio Annotation Generic annotations such as Comments and References Bio Search hierarchy contains Bio AlignIO, Bio SimpleAlign Multiple sequence alignments and their Input/Output modules related to database Bio LiveSeq, Bio Variation Sequence variations and mutations Bio Search, Bio SearchIO Sequence database searches and their Input/Output searches, and Bio Graphics conBio Tools Miscellaneous analysis tools tains modules that are related to Bio Tools Run Wrapper for executing local and remote analyses drawing (Fig. 1). The Bio Perl modBio Tree, Bio TreeIO Phylogenetic trees and their Input/Output ule itself is a simplified API that proBio Structure Protein structure data vides access to the most-commonly Bio Map, Bio MapIO Biological maps and their Input/Output Bio Biblio, Bio DB Biblio Bibliographic References and Database retrieval used Bioperl functions. Bio Graphics Graphical displays of sequences When designing Bioperl objects, we sought to provide a proa particular laboratory or institution and is written for immediate utility rather than reusability. This results in considerable inefficiency, as the same software is rewritten multiple times. The Bioperl toolkit brings together reusable Perl modules containing generalized routines specific to life-science information. A primary motivation behind writing the toolkit is the authors' desire to focus energies on a solution whose components can be shared rather than duplicating effort. In our minds, once a routine is written for parsing and interpreting sequence from EMBL and GenBank format sequence files, no one should ever have to write this routine again. In this spirit, we chose to make our code freely available under an open-source license (Open Source Initiative 2001), so that others could extend routines already in the Bioperl library and contribute their own routines as well. Just as the Human Genome Project was facilitated by public sharing of data, so has the open nature of the Bioperl project reduced the time for solutions and new tools to reach the community (Waterston et al. 2002). To be adopted by the community, our software has to be user friendly. To that end, Bioperl provides extensive documentation of all of the routines in each module, a graphical diagram of the objects in the toolkit, and a set of tutorials that lead the reader through the solutions to common tasks. Additionally, we have created a simplified interface to Bioperl that provides entry-level access to the toolkit. The goal of Bioperl is to help a user focus on her specific problem at hand, such as the logic needed to filter hits in a BLAST (Altschul et al. 1997) report by certain criteria, rather than on the actual mechanics of parsing that BLAST report.

1612

Genome Research
www.genome.org

Downloaded from www.genome.org on May 7, 2008 - Published by Cold Spring Harbor Laboratory Press

The Bioperl Toolkit

Figure 1 Rendering a sequence graphically with Bio Graphics. This image represents a 20-Kb segment of the C. elegans genome containing annotated genes, a cross-species alignment (C. elegans to C. briggsae), EST alignments, SNPs, PCR primer pairs, and a GC content histogram. The module's flexible glyph-based architecture allows the application programmer to adjust precisely how to display biological objects. Glyphs allow the programmer to define different symbols for different data types or data sources and each are drawn as a separate track in the image. The module is also suitable for illustrating the extent of protein domains, physical (clone) maps, and horizontal maps.

gramming interface that is very easy to use, but at the same time, could be easily extended in its capabilities and behavior through code reuse. Using an object-oriented paradigm, we followed certain design principles. First, separate the interface from the implementation. The key information about a component is the method names and their list of accepted arguments. Similar in concept to interfaces in Java, we built interfaces as collections of methods that describe the expected behavior of a module, but do not do any of the work. Child modules implement the interfaces, providing specializations of their parents to perform specific tasks. To help distinguish implementation modules from interface definitions, we used a capital I appended to the object name. This principle is based on the well-established methodology of specifying a given module's Abstract Data Type by defining how a given module will behave without specifying the mechanism by which it achieves this end. For example, Bio SeqFeatureI describes the contract for all modules that are features on sequences. This includes methods for start, end, strand, and access to comments and other attributes via tag/value pairs. All modules in the Bio SeqFeature hierarchy implement this interface (Fig. 2).

The power of this design is that operations that expect a Bio SeqFeatureI, such as operations in the Bio Graphics modules, can operate on anything that implements the Bio SeqFeatureI interface. In this manner, sequence annotation that is retrieved from a DAS server (Dowell et al. 2001), a local file, or a database server can all be drawn as an image with the same methods in the Bio Graphics modules. Second, generalize common routines into a single module, providing a base framework for the respective operations. As an example, we centralized the basic input/output (IO) operations into an IO object, called Bio Root IO. Because all modules that need IO data access use operations from the IO module, these operations are implemented across the entire package in a consistent way. This design choice also provides a single location for applying improvements to the shared methods. Third, use the Factory and Strategy patterns (Gamma et al. 1994) as much as possible. A Strategy pattern defines one or more operations that a particular implementation must support. For example, Bio SeqIO uses a Strategy pattern by specifying that Bio SeqIO modules must support the operation next_seq( ). Various parsers implement their own parsing

Genome Research
www.genome.org

1613

Downloaded from www.genome.org on May 7, 2008 - Published by Cold Spring Harbor Laboratory Press

Stajich et al.

details of the sequence file format and the Bio SeqIO object hierarchy. Application code can be written generally to handle sequence input without worrying about whether it is processing a sequence file in GenBank, EMBL, SwissProt, or BSML format, or whether the sequence data is local, or being retrieved dynamically from a remote database via the Internet. Bioperl is written purely in Perl and requires at least version 5.005 of the Perl interpreter (the current stable version of Perl as of the time of writing is 5.8.0). The toolkit has been validated for cross-platform compatibility on most UNIX and UNIX-like operating systems. In addition, Bioperl has been tested and runs on Macintosh OS X and Microsoft Windows operating systems. Because the Bioperl toolkit deFigure 2 This figure shows a portion of the Bioperl object model including the interfaces (shown in pends on the Perl interpreter, there italicized type) for sequences (PrimarySeqI, SeqI, RichSeqI) and their implementations PrimarySeq are a number of rare cases in which (general sequence), Seq (sequence with features), RichSeq (sequence with features and rich annotaits behavior is not consistent across tion), LargePrimarySeq (for sequences too large to be held in a program's memory), and LargeSeq (large sequences with features). Also included in the diagram is the sequence feature interface (Seqdifferent versions of Perl or between FeatureI) and its implementations Similarity (manage similarity information), FeaturePair (paired feaversions of Perl on certain operatture information), and SimilarityPair (paired similarity information such as a pair-wise alignment inforing systems. Descriptions of these mation). Additionally, the diagram shows the location objects that manage Simple (start, end, and version-specific problems and their strand information), Split (multiple start and end spots on a sequence such as a set of exons), and solutions are available from the Bioso-called Fuzzy locations (where start, end or span is not exact) for sequence features. perl Web site. In addition to pure Perl solualgorithms, but each parser has a next_seq( ) method that tions to bioinformatics problems, Bioperl can take advantage provides consistency and eases usage. Example usage of the of external data analysis packages. Bioperl is capable of parsBio SeqIO module can be seen in Figure 3. ing the output from a variety of programs including BLAST The Factory pattern is a design pattern used when a mod[both NCBI and WUBLAST (Gish 2002) versions], HMMer ule must create an object but cannot know what specific sub(Eddy 2001), ClustalW (Thompson et al. 1994), T-Coffee type must be created. It can serve as an aggregator for a set of (Notredame et al. 2000), Phylip (Felsenstein 1983), many EMmodules that implement the same Strategy. For example, the BOSS (Rice et al. 2000) programs, Genscan (Burge and Karlin Bio SeqIO module acts as a Factory that produces specific 1997), and 18 others. In addition, it can launch remote analysequence file parsers for different sequence formats. When the ses using the EMBOSS suite, NCBI BLAST, and the multiple user asks Bio SeqIO to parse a particular sequence file, sequence alignment programs ClustalW and T-Coffee. In Bio SeqIO determines the correct parser to instantiate and some cases, when an external package is not available, Bioperl invoke, thereby shielding application code from the technical will fall back to using a slower method, either by emulating the package in pure Perl or by invoking a network-based analysis service such as the NCBI BLAST analysis queue. Additional work is in progress to incorporate into the project access to remote analysis services at the European Bioinformatics Institute (EBI) (Novella: http://industry.ebi.ac. uk/novella) and Pasteur Institute (Pise: http://bioweb.pasteur. fr). For us to produce uniform software code, we established coding guidelines that are extensions of widely accepted object-oriented programming style. All modules were required Figure 3 Retrieving a sequence from a remote database with to meet minimal standards before release. These standards Bio DB EMBL. This code retrieves an mRNA sequence in EMBL forinclude a complete set of regression tests, well-formed embedmat from the EBI EMBL databank with the accession no. U14680 and ded documentation for each method, and a concise example writes the sequence out in GenBank format to the terminal. One could replace Bio DB EMBL with Bio DB GenBank and instead code in the SYNOPSIS section of each module's documentaretrieve the sequence from NCBI just as easily, as the software can tion. We use the Perl embedded documentation format read and write both EMBL and GenBank formats and is able to con(called POD, or Plain Old Documentation) to interleave docunect to both services through the World Wide Web. The retrieved mentation and the source code. This documentation can be sequence can then be passed to Bio Graphics for graphical renderconverted to text, TeX, or HTML. We have used the Pdoc ing, to the Bio SeqIO interface for writing to a file, or to the ODBA interfaces for storage in a relational database. (http://pdoc.sourceforge.net) tool to generate colored and hy-

1614

Genome Research
www.genome.org

Downloaded from www.genome.org on May 7, 2008 - Published by Cold Spring Harbor Laboratory Press

The Bioperl Toolkit

perlinked documentation in HTML for easy online browsing available at http://doc.bioperl.org. Our development process often starts when someone presents an idea for a needed tool on our mailing list. Ideally, a prototype or example code is posted, and we discuss ideas for implementation and common scenarios for where the functionality is needed. The developer then writes, or prepares from code he already has, an interface for the proposed module that describes the basic routines the module will implement. For the new module, we require a set of regression tests to be written. This is intended to ensure that the module satisfies its declared interface and can be tested easily later on when other modules that may interact with it have been updated. Bioperl 1.0 >3000 such tests that passed on multiple platforms before the toolkit was declared ready for release. Finally, all Bioperl code is subject to ongoing code review by and with the core developer group. This methodology is derived in large part from the software development strategy called Extreme Programming (Beck 1999). This process is highly iterative and modules are often revisited and improved depending on the needs of the developer. We attempt to always maintain a backward compatibility, so that code that depends on an earlier version of the module will continue to work. To support multiple developers in different time zones and institutions, the entire Bioperl source code is hosted by the Open Bioinformatics Foundation (OBF) (http://www. open-bio.org) on a server in which our code and documentation is shared among developers and interested users. Information on how to obtain the source directly from our server is available at the project Web site http://www.bioperl.org and the source code server at http://cvs.open-bio.org.

Figure 4 Report parsing with Bio SearchIO. This code parses a BLAST report from a file called report.bls and saves, in an array called @HitsToSave, only the hits that have High-scoring Segment Pairs (HSPs) meeting an e-value and length threshold. In this case, any hit with e-value >0.001 or length < 120 residues will be excluded. Once the array is built, the names of each of the hits that had a HSP that met the criteria are printed out. To parse a FASTA (Pearson and Lipman 1988) report file one simply changes the format specification from blast to fasta.

RESULTS
Bioperl has >20 active developers led by a core of five primary developers who ensure that standards are met, prepare code releases, and set the vision for the project. At the time of writing, the mailing lists for the project include 1300 subscribers, and our Web site recieves an average of 10,000 unique visitors each month. The project has been used in a variety of endeavors including genome sequencing, annotation, sequence variation elucidation, disease gene discovery, and comparative genomics. An example using Bioperl modules to complete the task of retrieving sequences from a remote database is shown in Figure 3, and an example of parsing a BLAST report can be seen in Figure 4. By far, the most advanced use of the Bioperl toolkit has come through the EnsEMBL (Hubbard et al. 2002) project. The basic sequence handling, file format parsing, and sequence features for annotation model have been used as building blocks for automatically annotating the Danio rerio, Drosophila melanogastor, Takifugu rubripes, Homo sapiens, Anopheles gambiae, and Mus musculus genomes (http://www. ensembl.org). Additionally, the Genquire (Wilkinson et al. 2002) annotation package is built on top of the Bioperl object model and stores sequence and annotation data in a relational database. The interactive sequence-rendering capabilities are partitioned into a specific Bioperl package called bioperl-gui. The Generic Model Organism Browser (GBrowse) (L.D. Stein, A. Day, T. Harris, A. Arva, S. Shu, S. Lewis, and C. Mungall, in prep.), Distributed Annotation System Perl (DAS) server (Dowell et al. 2001), and TFBS (Lenhard and Wasser-

man 2002) all use the Bioperl object model to describe sequences and Bioperl tools to complete analyses. The GBrowse system is a Web interface to databases of features for a genome project. The DAS system provides researchers a means to annotate sequences locally and publish the annotations to the community via the DAS XML protocol. TFBS provides a Perl implementation of objects for DNA sequence pattern representation by matrix profiles, with associated methods for searching the sequences for the occurrence of patterns, pattern storage, and generation of new patterns. The implementation uses Bioperl sequence, alignment, sequence features, and feature pair objects.

Interoperability
Sometimes the best solution for a bioinformatics problem is a hybrid of multiple tools. Providing interoperability between languages allows a programmer using the toolkit to build components using work done in other languages and projects. These tools, written in different programming languages such as C, Java, and Python, can be used within a Perl program simply by invoking them (a process often called shelling out). In some situations, these tools require that data be available in a certain format or within a certain database. Bioperl provides software layers that can, for example, populate a database with sequence information that can be accessed and used to generate an interactive graphical interface provided by the Biojava toolkit. In other cases, Bioperl is used to create files in a format recognized by other programs so that they can perform their analyses. Bioperl also supports a number of Extensible Markup Language (XML) standard data exchange formats accepted in the Bioinformatics community. Previous work has outlined scenarios in which XML has been useful in a biological context (Achard et al. 2001). XML standards supported by Bioperl

Genome Research
www.genome.org

1615

Downloaded from www.genome.org on May 7, 2008 - Published by Cold Spring Harbor Laboratory Press

Stajich et al.

include the sequence markup formats Bioinformatics Sequence Markup Language (BSML; http://www.bsml.org) and Berkeley Drosophila Genome Project's (http://www.fruitfly. org) Genome Annotation Markup Elements (GAME; http:// www.bioxml.org/dtds/index.html), NCBI BLAST XML for BLAST reports, and the bibliographic standards Medline XML provided by the European Bioinformatics Institute's Bibliographic Query Service (BQS; http://industry.ebi.ac.uk/ openBQS/) and Entrez Pubmed XML format (Wheeler et al. 2002). By supporting these XML-based formats, programs using Bioperl are able to process data from a growing number of data sources that have adopted them as their standard. Furthermore, the extensible nature of XML allows new features to be added to the data formats without breaking existing parsers and code. Software can interoperate not only through the invocation of external programs, but also through invoking methods on remote components possibly written in a different programming language from the calling component. Such a mechanism constitutes the tightest integration of reusable software components in a language-independent way. The Common Object Request Broker Architecture (CORBA) (Object Management Group 2001) provides an architecture for enabling this technology. This technology has been applied to biological data at the EBI in their Radiation Hybrid (Rodriguez-Tome and Lijnzaad 2001) and EMBL Nucleotide Data´ bases (Wang et al. 2000). CORBA implementations are available from commercial vendors (e.g., Inprise's VisiBroker, IONA's ORBacus) as well as from open-source projects (e.g., ORBit, MICO). Bioperl is compliant with the BioCORBA project (http://www.biocorba.org), one of the proposed standards for CORBA components for biological processes. BioCORBA is also supported by the Biojava (http://www. biojava.org) and Biopython (http://www.biopython.org) projects. The standard is under consideration for adoption by the Management Group's Life Science Research group (http:// lsr.ebi.ac.uk) and is included in the proposed Open Bioinformatics Database Access (OBDA; http://obda.open-bio.org) standard for sequence data access. Bioperl's support for BioCORBA allows applications written on top of Bioperl to interact transparently with remote BioCORBA servers to perform operations as diverse as protein domain analysis and bibliographic retrieval, without knowing any of the details of the CORBA protocol. Last, Bioperl fully supports the recent Open Bioinformatics Database Access initiative (OBDA), a languageindependent relational database schema for the storage and retrieval of GenBank/EMBL entry-based sequences. By supporting this common schema, sequence objects that are created and maintained by Bioperl can be accessed and manipulated by OBDA-compliant programs written in Java, Python, Ruby, or C. This provides a level of read/write cross-platform data compatibility unmatched by any other sequence database project, and enables extensive enterprise-level application development.

DISCUSSION
Open-source development has proven to be a valuable and productive mechanism for creation of the toolkit. No single individual owns the project, rather it is owned by the community of contributors. The community approach prevents the death of a project due to loss of interest by the sole developer and does not permit project stagnation in

the confines of a single laboratory in which a single individual or group is responsible for the continued vitality of a project. The original Bioperl project team has been replaced completely over the last 7 yr as members leave the project and new contributors join; however, the project aims have remained focused, whereas the functionality has continued to expand. Throughout the development process, we learned a great deal about appropriate software practices for a diverse group of contributors. Our programming methodology, which includes defining use cases for our software, establishing a comprehensive regression test suite, and utilizing code reviews or audits of contributed source code, helped the community develop code that is compatible and consistent. The principles of good design and good documentation have made it easier for new developers to join the project. A number of previous collaborative projects to develop comprehensive libraries for the life sciences have produced unsatisfactory results, or have been aborted prior to fruition. We believe that in many of these cases, ongoing development was stymied by a lack of commitment to open-source principles. For example, BioWidgets, an early attempt to create a Java-based biological toolkit, did not adopt an opensource methodology at its inception. This left it open to intellectual property disputes, and ultimately the project dissolved as early contributors withdrew their software from the project (N. Goodman, pers. comm.). In contrast, none of the software placed in Biope